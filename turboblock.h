//==============================================================================
// PROJECT:         zqloader
// FILE:            turboblock.cpp
// DESCRIPTION:     Defintion of class TurboBlocks
// 
// Copyright (c) 2023 Daan Scherft [Oxidaan]
// This project uses the MIT license. See LICENSE.txt for details.
//==============================================================================

#pragma once


#include "datablock.h"
#include "symbols.h"        // Symbols member
#include <iosfwd>
#include <memory>           // std::unique_ptr
#include <chrono>



class TurboBlock;
class SpectrumLoader;

enum class CompressionType : uint8_t
{
    none,       // No compression; just copy to m_dest_address when given
    rle,
    automatic,  // will never be send to spectrum
};
std::ostream& operator << (std::ostream& p_stream, CompressionType p_enum);



/// This class can be seen as the c++ counterpart of the zqloader turboloader written in z80 assember.
/// Maintains a chain of 'TurboBlocks', those are datablocks loaded that can be loaded by zqloader turbo loader.
/// Also maintains the symbols as generated by sjasmplus in an export file - see class Symbols.
/// One reason for this class is to put a block that overlaps our loader code (zqloader.z80asm)
/// at last position. Or handle the situation when the loader at BASIC REM statement is overwritten.
/// Or when all is overwritten eg at snapshots.
/// And handle the USR start address for chain of blocks so zqloader.z80asm knows.
class TurboBlocks
{
public:
    // What to do after a block was loaded
    enum AfterBlock
    {
        LoadNext = 0,               // go on to next block
        CopyToScreen = 1,           // copy loader to screen, then go on to next block
        ReturnToBasic = 2,          // return to basic
        // all other values are like RANDOMIZE USR xxxxx so start MC there.
    };
public:
    /// CTOR using given SpectrumLoader.
    /// Take an export file name that will be used to load symbols.
    /// TPath must be std::filesystem::path
    template <class TPath>
    TurboBlocks(SpectrumLoader& p_spectrumloader, const TPath &p_symbol_file_name);

    /// DTOR
    ~TurboBlocks();

    /// Load at normal speed, typically loads zqloader.tap.
    TurboBlocks& Load(const std::filesystem::path& p_filename, std::string p_zxfilename);

    /// Set durations in T states for zero and one pulses.
    TurboBlocks& SetDurations(int p_zero_duration, int p_one_duration);

    /// Set ZQLoader parameter
    TurboBlocks& SetBitLoopMax(int p_value)
    {
        m_bit_loop_max = p_value;
        return *this;
    }

    /// Set ZQLoader parameter
    TurboBlocks& SetBitOneThreshold(int p_value)
    {
        m_bit_one_threshold = p_value;
        return *this;
    }

    /// Set compression type.
    TurboBlocks& SetCompressionType(CompressionType p_compression_type)
    {
        m_compression_type = p_compression_type;
        return *this;
    }


    /// Add given Datablock as Turboblock at given address. 
    /// Check if zqloader (upper) is overlapped.
    /// Check if zqloader (lower, at basic) is overlapped.
    TurboBlocks& AddDataBlock(DataBlock&& p_block, uint16_t p_start_adr);


    /// Convenience. Add a Datablock as Turboblock at given symbol name address (see class Symbols).
    TurboBlocks& AddDataBlock(DataBlock&& p_block, const std::string& p_symbol)
    {
        return AddDataBlock(std::move(p_block), m_symbols.GetSymbol(p_symbol));
    }



    /// Add just a header with a 'copy to screen' command.
    /// Mainly for debugging!
    TurboBlocks& CopyLoaderToScreen()
    {
        m_loader_at_screen = true;
        DataBlock empty;
        AddTurboBlock(std::move(empty), 12345);
        return *this;
    }


    /// Move all added turboblocks to SpectrumLoader as given at CTOR.
    /// p_usr_address: when done loading all blocks end start machine code here as in RANDOMIZE USR xxxx
    /// p_clear_address: when done loading put stack pointer here, which is a bit like CLEAR xxxx
    void MoveToLoader(uint16_t p_usr_address, uint16_t p_clear_address = 0);

    /// Convenience public read access to Symbols as loaded by CTOR.
    const Symbols& GetSymbols() const
    {
        return m_symbols;
    }

private:
    bool HandleTapBlock(DataBlock p_block, std::string p_zxfilename);

    void SetByteToZqLoaderTap(DataBlock& p_block, const char* p_name, std::byte p_value) const;


    // Do 2 blocks overlap?
    template <class T1, class T2, class T3, class T4>
    static bool Overlaps(T1 p_start, T2 p_end, T3 p_start2, T4 p_end2)
    {
        return (int(p_end) > int(p_start2)) && (int(p_start) < int(p_end2));
    }



    // Add given datablock with given start address
    void AddTurboBlock(DataBlock&& p_block, uint16_t p_dest_address);

    // Add given turboblock
    void AddTurboBlock(TurboBlock&& p_block);
    

private:
    std::vector<TurboBlock> m_turbo_blocks;
    std::unique_ptr<TurboBlock> m_upper_block;          // when a block is found that overlaps our loader (nullptr when not)
    bool m_loader_at_screen = false;                    // when true the first block will have a 'copy loader to screen' command
    CompressionType m_compression_type = CompressionType::none;
    Symbols m_symbols;                                  // named symbols as read from EXP file
    //    int m_zero_duration = 80;
    //    int m_one_duration = 280;
    int m_zero_duration = 118;      // @@ see zqloader.asm
    int m_one_duration = 293;       // @@ 175 more (3.5 cycle)
    int m_bit_loop_max = 0;
    int m_bit_one_threshold = 0;
    SpectrumLoader& m_spectrumloader;

};



