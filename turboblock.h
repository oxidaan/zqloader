//==============================================================================
// PROJECT:         zqloader
// FILE:            turboblock.cpp
// DESCRIPTION:     Defintion of class TurboBlocks
// 
// Copyright (c) 2023 Daan Scherft [Oxidaan]
// This project uses the MIT license. See LICENSE.txt for details.
//==============================================================================

#pragma once


#include "datablock.h"
#include "symbols.h"        // Symbols member
#include <cstdint>
#include <iosfwd>
#include <memory>           // std::unique_ptr
#include <chrono>



class TurboBlock;
class SpectrumLoader;

enum class CompressionType : uint8_t
{
    none,       // No compression; just copy to m_dest_address when given
    rle,
    automatic,  // will never be send to spectrum
};
std::ostream& operator << (std::ostream& p_stream, CompressionType p_enum);



/// This class can be seen as the c++ counterpart of the zqloader turboloader written in z80 assember.
/// Maintains a chain of 'TurboBlocks', those are datablocks loaded that can be loaded by zqloader turbo loader.
/// Also maintains the symbols as generated by sjasmplus in an export file - see class Symbols.
/// One reason for this class is to put a block that overlaps our loader code (zqloader.z80asm)
/// at last position. Or handle the situation when the loader at BASIC REM statement is overwritten.
/// Or when all is overwritten eg at snapshots.
/// And handle the USR start address for chain of blocks so zqloader.z80asm knows.
class TurboBlocks
{
public:
    // What to do after a block was loaded
    enum AfterBlock
    {
        LoadNext = 0,               // go on to next block
        ReturnToBasic = 1,          // return to basic
        CopyToScreen = 2,
        // all other values are like RANDOMIZE USR xxxxx so start MC there.
    };
public:
    /// CTOR, take an EXP file name that will be used to load symbols.
    /// TPath must be std::filesystem::path
    template <class TPath>
    TurboBlocks(const TPath &p_symbol_file_name);

    /// DTOR
    ~TurboBlocks();

    /// Set duration T state times for zero and one
    TurboBlocks& SetDurations(int p_zero_duration, int p_one_duration);

    /// Set compression type.
    TurboBlocks& SetCompressionType(CompressionType p_compression_type)
    {
        m_compression_type = p_compression_type;
        return *this;
    }


    /// Add given Datablock as Turboblock at given address. 
    /// Check if zqloader (upper) is overlapped.
    /// Check if zqloader (lower, at basic) is overlapped.
    TurboBlocks& AddDataBlock(DataBlock&& p_block, uint16_t p_start_adr);


    /// Convenience. Add a Datablock as Turboblock at given symbol name address (see class Symbols).
    TurboBlocks& AddDataBlock(DataBlock&& p_block, const std::string& p_symbol)
    {
        return AddDataBlock(std::move(p_block), m_symbols.GetSymbol(p_symbol));
    }



    /// Add just a header with a 'copy to screen' command.
    /// Mainly for debugging!
    TurboBlocks& CopyLoaderToScreen()
    {
        m_loader_at_screen = true;
        DataBlock empty;
        AddTurboBlock(std::move(empty), 12345);
        return *this;
    }


    /// Move all added turboblocks to given SpectrumLoader.
    /// no-op when there are no blocks.
    /// p_usr_address: when done loading all blocks end start machine code here as in RANDOMIZE USR xxxx
    /// p_clear_address: when done loading put stack pointer here, which is a bit like CLEAR xxxx
    void MoveToLoader(SpectrumLoader& p_loader, uint16_t p_usr_address, uint16_t p_clear_address = 0);

    /// Convenience public access to Symbols as loaded by CTOR.
    const Symbols& GetSymbols() const
    {
        return m_symbols;
    }



private:
    template <class T1, class T2, class T3, class T4>
    static bool Overlaps(T1 p_start, T2 p_end, T3 p_start2, T4 p_end2)
    {
        return (int(p_end) > int(p_start2)) && (int(p_start) < int(p_end2));
    }



    // Add given datablock with given start address
    void AddTurboBlock(DataBlock&& p_block, uint16_t p_dest_address);

    // Add given turboblock
    void AddTurboBlock(TurboBlock&& p_block);
    

private:
    std::vector<TurboBlock> m_turbo_blocks;
    std::unique_ptr<TurboBlock> m_upper_block;          // when a block is found that overlaps our loader (nullptr when not)
    bool m_loader_at_screen = false;                    // when true the first block will have a 'copy loader to screen' command
    CompressionType m_compression_type = CompressionType::none;
    Symbols m_symbols;                                  // named symbols as read from EXP file
    //    int m_zero_duration = 80;
    //    int m_one_duration = 280;
    int m_zero_duration = 118;      // @@ see zqloader.asm
    int m_one_duration = 293;       // @@ 175 more (3.5 cycle)

};



