// ==============================================================================
// PROJECT:         zqloader
// FILE:            turboblocks.h
// DESCRIPTION:     Definition of class TurboBlocks
//
// Copyright (c) 2025 Daan Scherft [Oxidaan]
// This project uses the MIT license. See LICENSE.txt for details.
// ==============================================================================

#pragma once


#include <memory>            // std::unique_ptr
#include <filesystem>        // std::filesystem::path
#include "types.h"           // CompressionType

class Symbols;
class TurboBlock;
class SpectrumLoader;
struct MemoryBlock;



/// This class can be seen as the c++ counterpart of the zqloader turboloader written in z80 assember.
/// Maintains a chain of 'TurboBlocks', those are datablocks that can be loaded by zqloader turbo loader.
/// Also maintains the symbols as generated by sjasmplus in an export file - see class Symbols.
/// Tasks for this class:
/// - To load a block that overlaps our Z80 loader code (zqloader.z80asm) (at upper memory)
///   at the (now unused, but equaly sized) loader code at BASIC REM statement. Also make sure it is last.
/// - Handle the situation when the loader at BASIC REM statement is overwritten.
/// - Handle situation when all is overwritten eg at snapshots (then move loader code to lower part of screen)
/// - Handle the USR start address for chain of blocks so zqloader.z80asm knows.
class TurboBlocks
{
public:

    /// CTORs
    TurboBlocks();
    TurboBlocks(TurboBlocks &&) noexcept;
    TurboBlocks(const TurboBlocks &) = delete;

    TurboBlocks & operator = (TurboBlocks &&) noexcept;
    TurboBlocks & operator = (const TurboBlocks &) = delete;

    /// DTOR
    ~TurboBlocks();


    /// Load given file at normal speed, typically loads zqloader.tap.
    /// Add zqloader.tap file (normal speed).
    /// Patches zqloader.tap eg BIT_LOOP_MAX etc.
    /// Also loads symbol file (has same base name).
    TurboBlocks& AddZqLoader(const std::filesystem::path& p_filename);

    ///  Is ZqLoader added (with AddZqLoader above)?
    bool IsZqLoaderAdded() const;

    /// Get # turbo blocks added
    size_t size() const;


    TurboBlocks& AddMemoryBlock(MemoryBlock p_block);

    /// p_usr_address: when done loading all blocks end start machine code here as in RANDOMIZE USR xxxx
    /// p_clear_address: when done loading put stack pointer here, which is a bit like CLEAR xxxx
    /// To be called after last block was added.
    /// Make sure:
    ///     to add upperblock (overwriting loader) as last in the chain.
    ///     patch loader code.
    ///     first block will copy loader to alternative location.
    /// To be called after adding last AddDataBlock, before MoveToLoader.
    /// p_usr_address: when done loading all blocks end start machine code here as in RANDOMIZE USR xxxxx
    ///     (When 0 return to BASIC)
    /// p_clear_address: when done loading put stack pointer here, which is a bit like CLEAR xxxxx
    TurboBlocks& Finalize(uint16_t p_usr_address, uint16_t p_clear_address = 0);
    

    /// Move all added turboblocks to SpectrumLoader as given at CTOR.
    /// Call after Finalize.
    /// to given SpectrumLoader.
    /// no-op when there are no blocks.
    TurboBlocks& MoveToLoader(SpectrumLoader& p_spectrumloader, bool p_is_fun_attribute = false);


    /// Set durations in T states for zero and one pulses.
    /// When 0 keep defaults.
    /// Set durations in T states for zero and one pulses.
    /// When 0 keep defaults.
    TurboBlocks& SetDurations(int p_zero_duration, int p_one_duration, int p_end_of_byte_delay);



    /// Set this ZQLoader parameter
    /// When 0 keep defaults.
    TurboBlocks& SetBitLoopMax(int p_value);


    /// Set this ZQLoader parameter
    /// When 0 keep defaults.
    TurboBlocks& SetZeroMax(int p_value);

    /// Set this ZQLoader parameter
    TurboBlocks& SetIoValues(int p_io_init_value, int p_io_xor_value);

    /// Set compression type.
    TurboBlocks& SetCompressionType(CompressionType p_compression_type);

    /// Set DeCompression speed (kb/sec). Determines how long to wait after block.
    TurboBlocks& SetDeCompressionSpeed(int p_kb_per_sec);



    /// Add just a header with a 'copy to screen' command (no data)
    /// Mainly for debugging!
    /// Add just a header with a 'copy to screen' command (no data)
    /// Mainly for debugging!
    TurboBlocks& CopyLoaderToScreen(uint16_t p_value);

    /// Set start of free space to copy loader including space for sp.
    TurboBlocks& SetLoaderCopyTarget(uint16_t p_value );



    /// Convenience public read access to Symbols as loaded by CTOR.
    const Symbols& GetSymbols() const;


    // Length needed when loader code needs to be moved away from BASIC location
    uint16_t GetLoaderCodeLength(bool p_with_registers) const;
   
    /// Take an export file name that will be used to load symbols.
    TurboBlocks& SetSymbolFilename(const std::filesystem::path& p_symbol_file_name);

private:
    class Impl;
    std::unique_ptr<Impl> m_pimpl;
}; 




